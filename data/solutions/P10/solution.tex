\documentclass{article}
\usepackage{amsmath}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{listings}

\newcommand{\ProblemTitle}{Binary Divisibility}
\newcommand{\Difficulty}{Easy}
\newcommand{\Tags}{easy, math, binary}
\newcommand{\Authors}{Admin}

\newcommand{\Statement}{
You are given a binary string $s$ of length $n$ ($1 \leq n < 10^5$) and an integer $k$ ($0 \leq k < 10^9$).
Interpret the string $s$ as a binary number (without leading 0b prefix).
Determine whether this binary number is divisible by $k$.
Print the value of `binary_string % k`. If k is 0, print -1.
}

\newcommand{\InputFormat}{
The first line contains two integers $n$ and $k$.
The second line contains a binary string $s$ of length $n$.
}

\newcommand{\OutputFormat}{
Print the value of `binary_string % k`. If k is 0, print -1.
}

\newcommand{\Constraints}{
\begin{itemize}
    \item $1 \leq n < 10^5$
    \item $0 \leq k < 10^9$
\end{itemize}
}

\newcommand{\SimpleAnswer}{
The solution involves iterating through the binary string from right to left, maintaining the remainder of the number formed so far modulo $k$. This avoids converting the large binary string to an integer and efficiently calculates the final remainder.
}

\newcommand{\DetailedExplanation}{
The problem asks us to determine the value of a large binary number modulo $k$.
The binary number is given as a string $s$, which can be very long, so we cannot convert it to an integer directly.

First, we need to handle the case where $k$ is 0. Division by zero is undefined, and the problem statement asks us to print -1 in this case.

If $k$ is not 0, the key idea is to calculate the value of the binary number modulo $k$.
We can process the binary string from right to left, character by character.
The value of a binary number is given by the sum of powers of 2 for each '1' bit.
$N = \sum_{i=0}^{n-1} b_i \cdot 2^i$, where $b_i$ is the $i$-th bit from the right.

We want to calculate $N \pmod{k}$. We can use the properties of modular arithmetic:
$(a + b) \pmod{k} = ((a \pmod{k}) + (b \pmod{k})) \pmod{k}$
$(a \cdot b) \pmod{k} = ((a \pmod{k}) \cdot (b \pmod{k})) \pmod{k}$

So, $N \pmod{k} = (\sum_{i=0}^{n-1} b_i \cdot 2^i) \pmod{k}$.
We can calculate the sum iteratively, keeping track of the powers of 2 modulo $k$.
}

\begin{document}

\section*{\ProblemTitle}

\subsection*{Difficulty}
\Difficulty

\subsection*{Tags}
\Tags

\subsection*{Authors}
\Authors

\section*{Problem Description}
\Statement

\subsection*{Input Format}
\InputFormat

\subsection*{Output Format}
\OutputFormat

\subsection*{Constraints}
\Constraints

\section*{Simple Answer}
\SimpleAnswer

\section*{Detailed Explanation}
\DetailedExplanation

\subsection*{Algorithm}
\begin{enumerate}
    \item If $k$ is 0, print -1.
    \item Otherwise:
    \begin{enumerate}
        \item Initialize `res = 0` and `power = 1`.
        \item Iterate through the binary string `s` from right to left.
        \item For each bit `c`:
        \begin{itemize}
            \item If `c` is '1', add the current `power` to `res`.
            \item `res = res % k`.
            \item Update `power = (power * 2) % k`.
        \end{itemize}
        \item After the loop, `res` will hold the final remainder. Print `res`.
    \end{enumerate}
\end{enumerate}

\subsection*{Modular Arithmetic Properties}
Modular arithmetic has the following properties for addition, subtraction, and multiplication:
\begin{itemize}
    \item Addition: $(a + b) \pmod{k} = ((a \pmod{k}) + (b \pmod{k})) \pmod{k}$
    \item Subtraction: $(a - b) \pmod{k} = ((a \pmod{k}) - (b \pmod{k}) + k) \pmod{k}$ (we add $k$ to handle negative results)
    \item Multiplication: $(a \cdot b) \pmod{k} = ((a \pmod{k}) \cdot (b \pmod{k})) \pmod{k}$
\end{itemize}
These properties allow us to perform arithmetic operations on large numbers by only keeping track of their remainders modulo $k$.

\subsection*{Python}
\begin{lstlisting}[language=Python]
n, k = map(int, input().split())
s = input()

if k == 0:
    print(-1)
else:
    res = 0
    power = 1
    for c in reversed(s):
        if c == '1':
            res = (res + power) % k
        power = (power * 2) % k
    print(res)
\end{lstlisting}

\subsection*{C++}
\begin{lstlisting}[language=C++]
#include <iostream>
#include <string>
#include <vector>

int main() {
    long long n, k;
    std::cin >> n >> k;
    std::string s;
    std::cin >> s;

    if (k == 0) {
        std::cout << -1 << std::endl;
        return 0;
    }

    long long res = 0;
    long long power = 1;

    for (int i = n - 1; i >= 0; i--) {
        if (s[i] == '1') {
            res = (res + power) % k;
        }
        power = (power * 2) % k;
    }

    std::cout << res << std::endl;

    return 0;
}
\end{lstlisting}

\subsection*{C}
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

int main() {
    long long n, k;
    scanf("%lld %lld", &n, &k);
    char s[100001];
    scanf("%s", s);

    if (k == 0) {
        printf("-1\n");
        return 0;
    }

    long long res = 0;
    long long power = 1;
    for (int i = n - 1; i >= 0; i--) {
        if (s[i] == '1') {
            res = (res + power) % k;
        }
        power = (power * 2) % k;
    }

    printf("%lld\n", res);

    return 0;
}
\end{lstlisting}

\end{document}